{
  "provider_afdah": "const URL = {\n    DOMAIN: \"http://afdah.to\",\n    SEARCH: `http://afdah.to/wp-content/themes/afdah/ajax-search2.php`,\n    HEADERS: {\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n        'Origin' : 'http://afdah.to',\n        'Accept-Language': 'vi-VN,vi;q=0.8,fr-FR;q=0.6,fr;q=0.4,en-US;q=0.2,en;q=0.2',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36',\n        'Accept': '*/*',\n        'X-Requested-With': 'XMLHttpRequest'\n    }\n};\n\nclass Afdah {\n    constructor(props) {\n        this.libs = props.libs;\n        this.movieInfo = props.movieInfo;\n        this.settings = props.settings;\n\n        this.state = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, cryptoJs }  = this.libs; \n        let { title, year, season, episode, type }              = this.movieInfo;\n\n        let detailUrl       = false;\n        const bodyRequest   = {\n            process: cryptoJs.AES.encrypt(title + '|||' + 'title', 'Watch Movies Online').toString()\n        };\n\n        let htmlSearch  = await httpRequest.postCloudflare(URL.SEARCH ,URL.HEADERS, bodyRequest);\n        let $           = cheerio.load(htmlSearch.data);\n        let itemSearch  = $('ul li');\n\n        itemSearch.each( function() {\n\n            let titleAfdah \t    = $(this).find('a').text().replace(/\\([0-9]+\\)/i, '').trim();\n\t\t\tlet id \t\t\t\t= $(this).find('a').attr('href');\n\t\t\tlet yearAfdah \t\t= $(this).find('a').text().match(/\\(([0-9]+)\\)/i);\n            yearAfdah \t\t\t= yearAfdah != null ? +yearAfdah[1] : 0;\n\n            if( stringHelper.shallowCompare(titleAfdah, title) && yearAfdah == year ) {\n                detailUrl = `${URL.DOMAIN}/${id}`;\n            }\n        });\n\n        this.state.detailUrl = detailUrl; \n        return;\n    }\n\n    async getHostFromDetail() {\n        const { httpRequest, cheerio } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n        console.log(this.state.detailUrl);\n\n        let hosts       = [];\n        let detailUrl   = this.state.detailUrl;\n        let htmlDetail  = await httpRequest.get(this.state.detailUrl);\n        let $           = cheerio.load(htmlDetail.data);\n        let servers     = ['cont_1', 'cont_3', 'cont_4', 'cont_5'];\n\n        for( let item of servers ) {\n\n            if( item == 'cont_5' ) {\n\n                $(`#cont_5 div table`).each( function() {\n\n                    let embed = $(this).find('a').attr('href');\n                    hosts.push({\n                        provider: {\n                            url: detailUrl,\n                            name: \"afdah\"\n                        },\n                        result: {\n                            file: embed,\n                            label: \"embed\",\n                            type: \"embed\"\n                        }\n                    })\n                });\n            } else {\n\n                let embed \t= $(`#${item} .jw-player`).attr('data-id');\n\t\t\t    if( embed != undefined ) {\n\n\t\t\t\t    embed \t\t= URL.DOMAIN + embed;\n\t\t\t\t\thosts.push({\n                        provider: {\n                            url: detailUrl,\n                            name: \"afdah\"\n                        },\n                        result: {\n                            file: embed,\n                            label: \"embed\",\n                            type: \"embed\"\n                        }\n                    })\n\t\t\t\t}\n            }\n        }\n\n        this.state.hosts = hosts;\n    }\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const afdah = new Afdah({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n\n    await afdah.searchDetail();\n    await afdah.getHostFromDetail();\n    return afdah.state.hosts;\n}\n\n\n\nexports.testing = Afdah;",
  "provider_primeware": "const URL = {\n    DOMAIN: \"http://www.primewire.ag\",\n    SEARCH: keyword => `http://www.primewire.ag/index.php?search_keywords=${keyword}&key=d6077aeec4e85692&search_section=1`,\n    DETAIL: (type, id, dummyText, season, episode) => {\n        if(type === 'tv') return `http://www.primewire.ag/${type}-${id}-${dummyText}/season-${season}-episode-${episode}`;\n        return `http://www.primewire.ag/watch-${id}-${dummyText}`;\n    }\n};\n\nclass Primeware {\n    constructor(props) {\n        this.libs = props.libs;\n        this.movieInfo = props.movieInfo;\n        this.settings = props.settings;\n\n        this.varHelper = {\n            urlSlug(string, spaceCharacter) {\n                return string.replace(/\\s/g, spaceCharacter);\n            },\n            extractIdFromSlug(string) {\n                // example: /watch-9594-The-Big-Bang-Theory-online-free\n                let matchArr = string.match(/([0-9])\\w+/g);\n                if(matchArr !== null) return matchArr[0];\n                return false;\n            }\n        };\n        this.state = {};\n    }\n\n    async searchDetail() {\n        const { httpRequest, cheerio } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n        let searchUrl = URL.SEARCH(this.varHelper.urlSlug(title, \"+\"));\n        let htmlSearch = await httpRequest.getHTML(searchUrl);\n        let $ = cheerio.load(htmlSearch);\n        let result = [];\n        $(\".index_item.index_item_ie\").each(function(){\n            result.push({\n                slug: $(this).find(\"a\").attr(\"href\"),\n                titleAndYear: $(this).find(\"a\").attr(\"title\").replace(\"Watch \", \"\")\n            });\n        });\n        let titleAndYear = `${title} (${year})`.toLowerCase();\n        for (let i=0; i<result.length; i++) {\n            if(result[i].titleAndYear.toLowerCase() == titleAndYear) {\n                let id = this.varHelper.extractIdFromSlug(result[i].slug);\n                if(id !== false) {\n                    this.state.detailUrl = URL.DETAIL(type, id, this.varHelper.urlSlug(title, \"-\"), season, episode);\n                    return;\n                }\n            }\n        }\n    }\n\n    async getHostFromDetail() {\n        const { httpRequest, cheerio } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n        console.log(this.state.detailUrl);\n        let htmlDetail = await httpRequest.getHTML(this.state.detailUrl);\n        let $ = cheerio.load(htmlDetail);\n        let redirectLinks = [];\n        let hosts = [];\n        $(\".movie_version_link\").each(function(index){\n            if(index === 0) return;\n            redirectLinks.push(URL.DOMAIN + $(this).find(\"a\").attr(\"href\"))\n        });\n        // console.log(redirectLinks);\n        let promiseArr = redirectLinks.map(async val => {\n            let host = await httpRequest.getRedirectUrl(val);\n            host !== false && hosts.push({\n                provider: {\n                    url: this.state.detailUrl,\n                    name: \"primeware\"\n                },\n                result: {\n                    file: host,\n                    label: \"embed\",\n                    type: \"embed\"\n                }\n            });\n        });\n        await Promise.all(promiseArr);\n        this.state.hosts = hosts;\n    }\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const primeware = new Primeware({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await primeware.searchDetail();\n    await primeware.getHostFromDetail();\n    return primeware.state.hosts;\n}\n\nexports.testing = Primeware;",
  "provider_alluc-hand": "const URL = {\n    DOMAIN: \"http://www.alluc.ee\",\n    SEARCH: (title, type, page=false, season=false, episode=false) => {\n        if(type == 'movie') {\n            // if( page != false ) return `http://www.alluc.ee/stream/${title}+%23newlinks?page=${page}`;\n            return `http://www.alluc.ee/stream/${title}`;  \n        }\n        if( page != false ) return  `http://www.alluc.ee/stream/${title}+s${season}e${episode}?page=${page}`;\n        return  `http://www.alluc.ee/stream/${title}+s${season}e${episode}`;\n    }\n};\n\nfunction algo_merge (stringHelper, title1, title2) {\n\n    title1 = stringHelper.removeSpecialCharacters(title1, true);\n    title2 = stringHelper.removeSpecialCharacters(title2, true);\n\n    let arrTitle1 = title1.split(' ');\n    let arrTitle1Temp = [];\n    let arrTitle2 = title2.split(' ');\n    let arrTitle2Temp = [];\n\n    for( let item of arrTitle1 ) {\n\n        if( item != ' ' ) {\n\n            arrTitle1Temp.push(item);\n        }\n    }\n\n    for( let item of arrTitle2 )  {\n\n        if( item != ' ' ) {\n\n            arrTitle2Temp.push(item);\n        }\n    }\n\n    for( let item of arrTitle2Temp ) {\n\n        title1 = title1.replace(item, '');\n    }\n\n    title1 = title1.trim();\n\n    if( title1.length == 0 ) return true;\n    return false;\n};\n\n// function ord(r) {\n//     var t = r + \"\",\n//         e = t.charCodeAt(0);\n//     if (e >= 55296 && 56319 >= e) {\n//         var o = e;\n//         return 1 === t.length ? e : 1024 * (o - 55296) + (t.charCodeAt(1) - 56320) + 65536\n//     }\n//     return e\n// }\n\n// function hta(r) {\n//     for (var t = r.toString(), e = \"\", o = 0; o < t.length; o += 2) e += String.fromCharCode(parseInt(t.substr(o, 2), 16));\n//     return e\n// }\n\n// function strrev(r) {\n//     return r.split(\"\").reverse().join(\"\")\n// }\n\n// function strswpcs(r) {\n//     for (var t = \"\", e = 0; e < r.length; e++) t += r[e].match(/^[A-Za-z]$/) ? r[e] === r[e].toLowerCase() ? r[e].toUpperCase() : r[e].toLowerCase() : r[e];\n//     return t\n// }\n\n// function decrypt(r, t, aaa, bbb, ccc, ddd, base64) {\n//     var e = \"\",\n//         o = r.substring(0, 3);\n//     r = r.substring(3), \"3\" + aaa + \"f\" == o ? r = strrev(base64.decode(r)) : \"f\" + bbb + \"0\" == o ? r = hta(strrev(r)) : \"6\" + ccc + \"3\" == o ? r = base64.decode(r) : \"5\" + ddd + \"a\" == o && (r = base64.decode(r));\n//     var s = 0;\n//     for (s = 0; s < r.length; s++) {\n//         var n = r.substr(s, 1),\n//             a = t.substr(s % t.length - 1, 1);\n//         n = Math.floor(ord(n) - ord(a)), e += n = String.fromCharCode(n)\n//     }\n//     return e\n// }\n\nfunction ord(r) {\n    var t = r + \"\",\n        e = t.charCodeAt(0);\n    if (e >= 55296 && 56319 >= e) {\n        var o = e;\n        return 1 === t.length ? e : 1024 * (o - 55296) + (t.charCodeAt(1) - 56320) + 65536\n    }\n    return e\n}\n\nfunction hta(r) {\n    for (var t = r.toString(), e = \"\", o = 0; o < t.length; o += 2) e += String.fromCharCode(parseInt(t.substr(o, 2), 16));\n    return e\n}\n\nfunction strrev(r) {\n    return r.split(\"\").reverse().join(\"\")\n}\n\nfunction strswpcs(r) {\n    for (var t = \"\", e = 0; e < r.length; e++) t += r[e].match(/^[A-Za-z]$/) ? r[e] === r[e].toLowerCase() ? r[e].toUpperCase() : r[e].toLowerCase() : r[e];\n    return t\n}\n\nfunction decrypt(r, t, aaa, bbb, ccc, ddd, base64) {\n    var e = \"\",\n        o = r.substring(0, 3);\n    r = r.substring(3), \"3\" + aaa + \"f\" == o ? r = strrev(base64.decode(r)) : \"f\" + bbb + \"0\" == o ? r = hta(strrev(r)) : \"6\" + ccc + \"3\" == o ? r = base64.decode(strrev(r)) : \"5\" + ddd + \"a\" == o && (r = base64.decode(strswpcs(r)));\n    var s = 0;\n    for (s = 0; s < r.length; s++) {\n        var n = r.substr(s, 1),\n            a = t.substr(s % t.length - 1, 1);\n        n = Math.floor(ord(n) - ord(a)), e += n = String.fromCharCode(n)\n    }\n    return e\n}\n\nclass AllucHand {\n    constructor(props) {\n        this.libs = props.libs;\n        this.movieInfo = props.movieInfo;\n        this.settings = props.settings;\n\n        this.state = {};\n    }\n\n\n\n    async searchDetail() {\n        const { httpRequest, cheerio, stringHelper } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n        \n        let searchUrl   = URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+'), type, 1, season, episode);\n        let htmlSearch  = await httpRequest.getCloudflare(searchUrl);\n        let $           = cheerio.load(htmlSearch.data);\n        let result      = [];\n        let urlDetail   = [];\n\n        let item = $('#resultitems .resblock');\n\n        item.each(function() {\n\n\t\t\tif( !$(this).hasClass('resblockx') ) {\n                \n                let hrefMovie   = URL.DOMAIN +  $(this).find('.title a').attr('href');\n\t\t\t\tlet title1      = $(this).find('.title a').text();\n                let title2      = $(this).find('.sourcetitle').text();\n                \n                if( algo_merge(stringHelper, title, title1) || algo_merge(stringHelper, title, title2) ) {\n\n                    if( type == 'movie' ) {\n\n                        if( title1.indexOf(year) != -1 || title2.indexOf(year) != -1 || hrefMovie.indexOf(year) != -1 ) {\n                            urlDetail.push(hrefMovie);\n                        }\n                        \n                    } else if( type == 'tv' ) {\n\n                        if( title1.indexOf(infoParams.season) != -1 && title1.indexOf(infoParams.episode) != -1 && title2.indexOf(infoParams.season) != -1 && title2.indexOf(infoParams.episode) != -1  )   {\n\n                           urlDetail.push(hrefMovie); \n                        }\n                    }\n                    \n                }\n\t\t\t}\n        });\n        \n    \n        this.state.urlDetail = urlDetail;\n        return;\n    }\n\n\n    async getHostFromDetail() {\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.urlDetail) throw new Error(\"NOT_FOUND\");\n\n        let hosts           = []; \n        let redirectLinks   = [];\n  \n        for( let item of this.state.urlDetail ) {\n\n            let htmlDetail  = await httpRequest.getCloudflare(item);\n            htmlDetail      = htmlDetail.data;\n            let $           = cheerio.load(htmlDetail); \n            let script      = $('.linktitleurl script').html();\n            let token       = $('#rawURLStextbox').text().trim();\n            let option      = htmlDetail.match(/decrypt\\(\\'[^\\']+\\' *\\, *\\'([^\\']+)/i);\n            option          = option != null ? option[1] : false;\n\n            let aaa = htmlDetail.match(/var *aaa *\\= ([0-9]+)/i);\n            let bbb = htmlDetail.match(/var *bbb *\\= ([0-9]+)/i);\n            let ccc = htmlDetail.match(/var *ccc *\\= ([0-9]+)/i);\n            let ddd = htmlDetail.match(/var *ddd *\\= ([0-9]+)/i);\n            aaa = aaa != null ? +aaa[1] : false;\n            bbb = bbb != null ? +bbb[1] : false;\n            ccc = ccc != null ? +ccc[1] : false;\n            ddd = ddd != null ? +ddd[1] : false;\n\n            if( token != false && aaa != false && bbb != false && ddd != false ) {\n\n                let host = decrypt(token, option, aaa, bbb, ccc, ddd, base64);\n\n                if( host.indexOf('http') != -1 ) {\n\n                    host !== false && hosts.push({\n                        provider: {\n                            url: item,\n                            name: \"alluc-hand\"\n                        },\n                        result: {\n                            file: host,\n                            label: \"embed\",\n                            type: \"embed\"\n                        }\n                    });\n                }\n                \n            }\n        }\n\n        this.state.hosts = hosts;\n    }\n\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const primeware = new AllucHand({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await primeware.searchDetail();\n    await primeware.getHostFromDetail();\n    return primeware.state.hosts;\n}\n\n\nexports.testing = AllucHand;",
  "provider_flixanity": "const URL = {\n    DOMAIN: \"https://flixanity.mobi\",\n    SEARCH: 'https://api.flixanity.mobi/api/v1/0A6ru35yevokjaqbb3',\n    TOKEN_API_EMBED: 'eCNBuxFGpRmFlWjUJjmjguCJI',\n    EMBED_URL: `https://flixanity.mobi/ajax/gonlflhyad.php`,\n    KEY_SL: '9fc895fbb0b23f1c0fb8e5a5fe02f7b5',\n    HEADERS: {\n        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',\n        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'\n    }\n};\n\n\n\nclass Flixanity {\n    constructor(props) {\n        this.libs = props.libs;\n        this.movieInfo = props.movieInfo;\n        this.settings = props.settings;\n\n        this.state = {};\n    }\n\n\n\n    async searchDetail() {\n        const { httpRequest, cheerio, stringHelper }    = this.libs; \n        let { title, year, season, episode, type }      = this.movieInfo;\n\n        let dataBody = {\n            sl: URL.KEY_SL,\n            q: stringHelper.convertToSearchQueryString(title)\n        };\n        \n        let resultSearch = await httpRequest.postCloudflare(URL.SEARCH, {}, dataBody);\n\n        if( resultSearch.data == null ) return;\n\n        for( let item of resultSearch.data )  {\n\n            if( stringHelper.shallowCompare(item.title, title) ) {\n\n                if( item.type == 'movie' && type == 'movie' && item.year == year ) {\n\n                    this.state.detailUrl = URL.DOMAIN + item.permalink;\n                } else if( item.type == 'tv' && type == 'tv' ) {\n    \n                    this.state.detailUrl = `${URL.DOMAIN}${item.permalink}/season/${season}/episode/${episode}`;\n                }\n            }\n            \n        }\n\n        return;\n    }\n\n\n\n    async getHostFromDetail() {\n        const { httpRequest, cheerio } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n        console.log(this.state.detailUrl);\n\n        let hosts       = [];\n        let {type}      = this.movieInfo;\n        let actionEmbed = type == 'movie' ? 'getMovieEmb' : 'getEpisodeEmb';\n        let htmlDetail  = await httpRequest.get(this.state.detailUrl, URL.HEADERS);\n        let elid        = htmlDetail.data.match(/elid *= *\\\"([^\"]*)/);\n        elid            = elid != null ? elid[1] : false;\n\n        if( elid != false ) {\n\n            let dataBody = {\n                action: actionEmbed,\n                idEl: elid,\n                token: URL.TOKEN_API_EMBED,\n                nopop: ''\n            };\n            let resultApi = await httpRequest.postCloudflare(URL.EMBED_URL, {}, dataBody);\n\n            for( let item in resultApi.data ) {\n\n                let embed   = resultApi.data[item].embed.match(/src=\"([^\"]*)/i);\n                embed       = embed != null ? embed[1] : false;\n\n                embed && hosts.push({\n                    provider: {\n                        url: this.state.detailUrl,\n                        name: \"flixanity\"\n                    },\n                    result: {\n                        file: embed,\n                        label: \"embed\",\n                        type: this.isEmbed(embed) ? \"embed\" : 'direct'\n                    }\n                });\n            }\n        }\n\n        this.state.hosts = hosts;\n    }\n\n\n\n    isEmbed(link) {\n\n        if( link.indexOf('statics2.vidcdn.pro') != -1 ) {\n            return false;\n        } else if( link.indexOf('stream2.m4ukido.com') != -1 ) {\n            return false;\n        } \n\n\n        return true;\n    }\n\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const flixanity = new Flixanity({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await flixanity.searchDetail();\n    await flixanity.getHostFromDetail();\n    return flixanity.state.hosts;\n}\n\nexports.testing = Flixanity;",
  "provider_mytv": "const URL = {\n    DOMAIN_API: \"http://api.teatv.net/api/v2/get_link\",\n    DOMAIN_MOVIEDB: (title) => {\n        return `http://api.themoviedb.org/3/search/multi?api_key=07824c019b81ecf7ad094a66f6410cc9&query=${title}`\n    },\n    DOMAIN_SEARCH_MOVIE: (id) => {\n        return `http://api.teatv.net/api/v2/get_link?id=${id}`;\n    },\n    DOMAIN_SEARCH_TVSHOW: (id, season, episode) => {\n       return `http://api.teatv.net/api/v2/get_link?id=${id}&season=${season}&episode=${episode}`;\n    }\n};\n\nclass MyTv {\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n        this.state      = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let detailUrl       = false;\n        let resultSearch    = await httpRequest.get(URL.DOMAIN_MOVIEDB(stringHelper.convertToSearchQueryString(title)));\n        let movieid         = false;\n\n        for( let item in resultSearch ) {\n\n            if( stringHelper.shallowCompare(title, resultSearch.results[item].name) ) {\n                movieid = resultSearch.results[item].id;\n                break;\n            }\n        }\n\n        if( id != false ) {\n\n            if( type == 'movie' ) {\n\n                this.state.detailUrl = URL.DOMAIN_SEARCH_MOVIE(movieid);\n            } else if( type == 'tv' ) {\n                this.state.detailUrl = URL.DOMAIN_SEARCH_TVSHOW(movieid, season, episode);\n            }\n        }\n\n        return;\n    }\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let hosts = [];\n\n        let result = await httpRequest.get(this.state.detailUrl);\n\n        if( result.error == 0 ) {\n\n            for( let item in result.message.not_direct ) {\n\n                for( let item1 in result.message.not_direct[item].link  ) {\n\n                    item1 && hosts.push({\n                        provider: {\n                            url: this.state.detailUrl,\n                            name: \"mytv\"\n                        },\n                        result: {\n                            file: item1,\n                            label: \"embed\",\n                            type: \"embed\"\n                        }\n                    })\n                }\n            }\n        }\n\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const mytv = new MyTv({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await mytv.searchDetail();\n    await mytv.getHostFromDetail();\n    return mytv.state.hosts;\n}\n\n\nexports.testing = MyTv;",
  "provider_playdk": "const URL = {\n    DOMAIN: `http://playdk.net`,\n    SEARCH: (title, page=false) => {\n        if( page != false ) return `http://playdk.net/page/${page}/?s=${title}`;\n\t    return `http://playdk.net/${title}`  \n    }\n};\n\nclass Playdk {\n    constructor(props) {\n        this.libs = props.libs;\n        this.movieInfo = props.movieInfo;\n        this.settings = props.settings;\n\n        this.state = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let htmlSearch  = await httpRequest.get(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')));\n\n        let $           = cheerio.load(htmlSearch);\n        let page        = $('.pagination span').first().text();\n        page = page.match(/of *([0-9]+)/i);\n\t    page = page != null ? +page[1] : 1;\n\n        await this.getDetailUrl(page, this.state);\n        return;\n    }\n\n\n    async getDetailUrl(page, state) {\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        for( let val = 1; val <= page; val++ ) {\n\n            let htmlCurrentPage = await httpRequest.get(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+'), page), {});\n            let $             = cheerio.load(htmlCurrentPage.data);\n            let item            = $('.search-page .result-item');\n            let arrItem         = [];\n\n            item.each( async function() {\n\n                let hrefMovie = $(this).find('.image .thumbnail a').attr('href');\n                let typeMovie = $(this).find('.image .thumbnail a span').text().trim().toLowerCase();\n                let titleMovie = $(this).find('.details .title a').text();\n                let yearMovie = $(this).find('.details .meta .year').text();\n                titleMovie = titleMovie.replace(/\\([0-9]+\\)/i, '').trim();\n\n                if( stringHelper.shallowCompare(title, titleMovie) ) {\n\n                    if( type == 'movie' && typeMovie == 'movie' ) {\n\n                        if( year == +yearMovie ) {\n                            state.detailUrl = hrefMovie;\n                            return;\n                        }\n                    } else if( type == 'tv' && typeMovie == 'tv' ) {\n\n                        await this.getHrefEpisode(hrefMovie, state);\n                        return;\n                    }\n                }\n            });\n        }\n        \n    }\n\n\n    async getHrefEpisode(hrefMovie, state) {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let htmlEpisode = await httpRequest.get(hrefMovie);\n        let $           = cheerio.load(htmlEpisode);\n        let itemSeason  = $('#seasons .se-c');\n\n        itemSeason.each(function() {\n\n            let seasonMovie = $(this).find('.se-t').text().trim();\n\n            if( +seasonMovie == season ) {\n\n\t\t\t\tlet itemEpisode = $(this).find('.se-a .episodios li');\n\n\t\t\t\tif( itemEpisode.length > 0 ) {\n\n\t\t\t\t\titemEpisode.each(function() {\n\n\t\t\t\t\t\tlet hrefEpisode = $(this).find('.episodiotitle a').first().attr('href');\n\t\t\t\t\t\tlet episodeMovies = $(this).find('.episodiotitle a').first().text();\n\t\t\t\t\t\tepisodeMovies = episodeMovies.match(/episode *([0-9]+)/i);\n\t\t\t\t\t\tepisodeMovies = episodeMovies != null ? +episodeMovies[1] : false;\n\n\t\t\t\t\t\tif( episodeMovies != false && +episodeMovies == episode ) {\n\n                            state.detailUrl = hrefEpisode;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n        });\n\n        return false;\n    }\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let detailUrl   = this.state.detailUrl;\n        let hosts       = [];\n        let htmlDetail  = await httpRequest.getHTML(this.state.detailUrl);\n        let $           = cheerio.load(htmlDetail);\n        let embeds = $('.metaframe.rptss');\n\n        if( embeds.length > 0 ) {\n    \n            embeds.each(function () {\n    \n                let linkEmbed = $(this).attr('src');\n                linkEmbed && hosts.push({\n                    provider: {\n                        url: detailUrl,\n                        name: \"playdk\"\n                    },\n                    result: {\n                        file: linkEmbed,\n                        label: \"embed\",\n                        type: \"embed\"\n                    }\n                });\n            });\n        }\n\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const mytv = new Playdk({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await mytv.searchDetail();\n    await mytv.getHostFromDetail();\n    return mytv.state.hosts;\n}\n\nexports.testing = Playdk;",
  "host_streamango": "var _0x0295 = [\n    \"split\",\n    \"BIGNF\",\n    \"length\",\n    \"PxMzv\",\n    \"fromCharCode\",\n    \"XMJZt\",\n    \"Uknst\",\n    \"indexOf\",\n    \"charAt\",\n    \"IgrAi\",\n    \"isrQD\",\n    \"NrFxr\",\n    \"Bfusx\",\n    \"EGuje\",\n    \"RTbDl\",\n    \"skTIa\",\n    \"tPROO\",\n    \"EyCRq\",\n    \"replace\",\n    \"reverse\",\n    \"NcOIe\",\n    \"4|6|5|0|7|3|2|1|8\",\n    \"6|2|9|8|5|4|7|10|0|3|1\",\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    \"WSNWx\"\n  ];\n  (function(_0x49bd0e, _0x12b3c1) {\n    var _0x43d5c3 = function(_0x5ed13b) {\n      while (--_0x5ed13b) {\n        _0x49bd0e[\"push\"](_0x49bd0e[\"shift\"]());\n      }\n    };\n    _0x43d5c3(++_0x12b3c1);\n  })(_0x0295, 0x1f0);\n  var _0x5029 = function(_0x311c35, _0x534915) {\n    _0x311c35 = _0x311c35 - 0x0;\n    var _0x5cc50c = _0x0295[_0x311c35];\n    return _0x5cc50c;\n  };\n  var k;\n  var d = function(_0x5ecd00, _0x184b8d) {\n    var _0x388cca = {\n      WSNWx: _0x5029(\"0x0\"),\n      BIGNF: function _0x4a2ce8(_0x269406, _0x73c036) {\n        return _0x269406 < _0x73c036;\n      },\n      PxMzv: _0x5029(\"0x1\"),\n      Uknst: function _0x5b25b8(_0x5f561b, _0x7441d8) {\n        return _0x5f561b + _0x7441d8;\n      },\n      XMJZt: function _0x60440f(_0x99a9bc, _0x219b5d) {\n        return _0x99a9bc != _0x219b5d;\n      },\n      IgrAi: function _0x46be5a(_0x2ee3bb, _0x403ad9) {\n        return _0x2ee3bb != _0x403ad9;\n      },\n      WrqtH: function _0x2eccdf(_0x2b036d, _0x5d7139) {\n        return _0x2b036d + _0x5d7139;\n      },\n      isrQD: function _0x4bf5cf(_0x44ec17, _0x413f9e) {\n        return _0x44ec17 | _0x413f9e;\n      },\n      NrFxr: function _0xf51086(_0x15906f, _0x2d8c9a) {\n        return _0x15906f << _0x2d8c9a;\n      },\n      Bfusx: function _0x3f5115(_0x459230, _0x5f166a) {\n        return _0x459230 & _0x5f166a;\n      },\n      EGuje: function _0x31a1fd(_0x3a0d6f, _0xc1be70) {\n        return _0x3a0d6f >> _0xc1be70;\n      },\n      RTbDl: function _0x4b61a6(_0x3bf700, _0x3d3525) {\n        return _0x3bf700 | _0x3d3525;\n      },\n      skTIa: function _0x2c54eb(_0x51c6d0, _0x331271) {\n        return _0x51c6d0 << _0x331271;\n      },\n      tPROO: function _0x1dadd1(_0x343c0a, _0x50af55) {\n        return _0x343c0a & _0x50af55;\n      },\n      EyCRq: function _0xfcdaa4(_0x145616, _0x5a35bc) {\n        return _0x145616 ^ _0x5a35bc;\n      },\n      NcOIe: _0x5029(\"0x2\")\n    };\n    var _0x42d795 = _0x388cca[_0x5029(\"0x3\")][_0x5029(\"0x4\")](\"|\"),\n      _0x3f3118 = 0x0;\n    while (!![]) {\n      switch (_0x42d795[_0x3f3118++]) {\n        case \"0\":\n          var _0x4a2f3a, _0x29d5bf, _0x3b6833, _0x426d70;\n          continue;\n        case \"1\":\n          while (\n            _0x388cca[_0x5029(\"0x5\")](_0x1598e0, _0x5ecd00[_0x5029(\"0x6\")])\n          ) {\n            var _0x5e7f50 = _0x388cca[_0x5029(\"0x7\")][_0x5029(\"0x4\")](\"|\"),\n              _0x455464 = 0x0;\n            while (!![]) {\n              switch (_0x5e7f50[_0x455464++]) {\n                case \"0\":\n                  _0x59b81a = _0x388cca[\"Uknst\"](\n                    _0x59b81a,\n                    String[_0x5029(\"0x8\")](_0x2e4782)\n                  );\n                  continue;\n                case \"1\":\n                  if (_0x388cca[_0x5029(\"0x9\")](_0x426d70, 0x40)) {\n                    _0x59b81a = _0x388cca[_0x5029(\"0xa\")](\n                      _0x59b81a,\n                      String[_0x5029(\"0x8\")](_0x5a46ef)\n                    );\n                  }\n                  continue;\n                case \"2\":\n                  _0x29d5bf = k[_0x5029(\"0xb\")](\n                    _0x5ecd00[_0x5029(\"0xc\")](_0x1598e0++)\n                  );\n                  continue;\n                case \"3\":\n                  if (_0x388cca[_0x5029(\"0xd\")](_0x3b6833, 0x40)) {\n                    _0x59b81a = _0x388cca[\"WrqtH\"](\n                      _0x59b81a,\n                      String[_0x5029(\"0x8\")](_0x2c0540)\n                    );\n                  }\n                  continue;\n                case \"4\":\n                  _0x2c0540 = _0x388cca[_0x5029(\"0xe\")](\n                    _0x388cca[_0x5029(\"0xf\")](\n                      _0x388cca[_0x5029(\"0x10\")](_0x29d5bf, 0xf),\n                      0x4\n                    ),\n                    _0x388cca[_0x5029(\"0x11\")](_0x3b6833, 0x2)\n                  );\n                  continue;\n                case \"5\":\n                  _0x2e4782 = _0x388cca[_0x5029(\"0x12\")](\n                    _0x388cca[_0x5029(\"0xf\")](_0x4a2f3a, 0x2),\n                    _0x388cca[_0x5029(\"0x11\")](_0x29d5bf, 0x4)\n                  );\n                  continue;\n                case \"6\":\n                  _0x4a2f3a = k[_0x5029(\"0xb\")](_0x5ecd00[\"charAt\"](_0x1598e0++));\n                  continue;\n                case \"7\":\n                  _0x5a46ef =\n                    _0x388cca[_0x5029(\"0x13\")](\n                      _0x388cca[_0x5029(\"0x14\")](_0x3b6833, 0x3),\n                      0x6\n                    ) | _0x426d70;\n                  continue;\n                case \"8\":\n                  _0x426d70 = k[\"indexOf\"](_0x5ecd00[\"charAt\"](_0x1598e0++));\n                  continue;\n                case \"9\":\n                  _0x3b6833 = k[\"indexOf\"](\n                    _0x5ecd00[_0x5029(\"0xc\")](_0x1598e0++)\n                  );\n                  continue;\n                case \"10\":\n                  _0x2e4782 = _0x388cca[_0x5029(\"0x15\")](_0x2e4782, _0x184b8d);\n                  continue;\n              }\n              break;\n            }\n          }\n          continue;\n        case \"2\":\n          _0x5ecd00 = _0x5ecd00[_0x5029(\"0x16\")](/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n          continue;\n        case \"3\":\n          k = k[_0x5029(\"0x4\")](\"\")\n            [_0x5029(\"0x17\")]()\n            [\"join\"](\"\");\n          continue;\n        case \"4\":\n          k = _0x388cca[_0x5029(\"0x18\")];\n          continue;\n        case \"5\":\n          var _0x2e4782, _0x2c0540, _0x5a46ef;\n          continue;\n        case \"6\":\n          var _0x59b81a = \"\";\n          continue;\n        case \"7\":\n          var _0x1598e0 = 0x0;\n          continue;\n        case \"8\":\n          return _0x59b81a;\n          continue;\n      }\n      break;\n    }\n  };\n\n  \n\n\nclass Streamango {\n\n  constructor(props) {\n\n      this.libs = props.libs;\n      this.settings = props.settings;\n      this.state = {};\n  }\n\n  async checkLive(url) {\n\n    let { httpRequest } = this.libs;\n\n    // you fill the die status text\n    // const dieStatusText = \"\";\n    let html = await httpRequest.getHTML(url);\n    // if(html.includes(dieStatusText)) return true;\n    return html;\n  }\n\n  async getLink(url) {\n\n    let { httpRequest, cheerio } = this.libs;\n    let html = await this.checkLive(url);\n\n    if( html == false ) throw new Error(\"LINK DIE\");\n\n    let $ = cheerio.load(html);\n    let targetedScriptString = $('script:contains(\"var srces\")').html();\n    if (targetedScriptString == null)\n    throw new Error(\"ERROR GET LINK STREAMANGO\");\n    let reg = /srces.push\\({type:\"video\\/mp4\"(.*);/g;\n    let matchArr = targetedScriptString.match(reg);\n    if (matchArr == null) throw new Error(\"ERROR GET LINK STREAMANGO\");\n\n    let sources = [];\n    let srces = [];\n    matchArr.forEach((val, index) => {\n        eval(val);\n    });\n    let resultArr = srces.map((val, index) => {\n        return {\n            file: \"https:\" + val.src,\n            label: val.height + \"p\",\n            type: \"direct\"\n        };\n    });\n\n    let arrPromise = resultArr.map(async function(val) {\n\n      let isDie = await httpRequest.isLinkDie(val.file);\n\n      if( isDie != false ) {\n        val.size = isDie;\n        sources.push(val);\n      }\n    });\n\n    await Promise.all(arrPromise);\n\n    return { \n      host: {\n          url: url,\n          name: \"streamango\"\n      },\n      result: resultArr\n    };\n  }\n}\n\n\nexports.default = (libs, settings) => new Streamango({ libs, settings });",
  "provider_seehduno": "const URL = {   \n    DOMAIN: `https://seehd.uno`,\n    SEARCH: (title, page=false) => {\n        if( page == false ) {\n            return `https://seehd.uno/?s=${title}`;\n        }\n        return `https://seehd.uno/page/${page}/?s=${title}`;\n    }\n};\n\nclass SeehdUno {\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n        this.state      = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let htmlSearch  = await httpRequest.getHTML(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')));\n        let $           = cheerio.load(htmlSearch);\n        let page        = $('#paginador .paginado ul li');\n\n        if( page.length <= 0 ) {\n            page = 1;\n        } else {\n            page = +page.last().text();\n        }\n\n        await this.getDetailUrl(page, this.state);\n\n        return;\n    }\n\n\n    async getDetailUrl(page, state) {\n\n        const { httpRequest, cheerio, stringHelper, base64 }    = this.libs; \n        let { title, year, season, episode, type }              = this.movieInfo;\n        \n        for( let i = 1; i <= page; i++ )  {\n\n            let htmlSearch  = await httpRequest.getHTML(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+'),i));\n            let $           = cheerio.load(htmlSearch);\n            let itemSearch  = $('.peliculas .items .item');\n\n            itemSearch.each(function() {\n\n\n                let hrefMovies      = $(this).find('a').attr('href');\n                let yearMovies      = $(this).find('.fixyear .year').text();\n                let titleMovies     = $(this).find('.fixyear h2').text();\n                let seasonMovies    = titleMovies.match(/season *([0-9]+)/i);\n                seasonMovies \t    = seasonMovies != null ? +seasonMovies[1] : false;\n                let episodeMovies   = titleMovies.match(/season *[0-9]+ *episode *([0-9]+)/i);\n                episodeMovies \t    = episodeMovies != null ? +episodeMovies[1] : false; \n                titleMovies         = titleMovies.replace('Watch', '').replace('Online', '').replace('Free', '').trim();\n                titleMovies         = titleMovies.replace(/\\([0-9]+\\)/i, '').trim();\n\n                if( seasonMovies != false && episodeMovies != false ) {\n\n                    titleMovies = titleMovies.replace(/\\â€“ *season.*/i, '').trim();\n                }\n                \n                if( stringHelper.shallowCompare(title, titleMovies) ) {\n\n                    if( type == 'movie' && +yearMovies == year ) {\n\n                        state.detailUrl = hrefMovies;\n                    } else if( type == 'tv' && seasonMovies == season && episodeMovies == episode ) {\n                        \n                        state.detailUrl = hrefMovies;\n                    }\n                }\n            });\n\n            return;\n        }\n    }\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let hosts = [];\n        let detailUrl   = this.state.detailUrl;\n        let htmlDetail  = await httpRequest.getHTML(this.state.detailUrl);\n        let $           = cheerio.load(htmlDetail);\n        let itemEmbed   = $('#player2 .movieplay');\n\n        itemEmbed.each(function() {\n\n            let script  = $(this).find('script').html();\n\t\t    let token   = script.match(/str *\\= *\\'([^\\']+)/i);\n            token \t    = token != null ? token[1] : false;\n            \n            if( token ) {\n\n                token           = unescape(token.replace(/@/g,'%'));\n                let linkEmbed   = token.match(/src *\\= *\\\"([^\\\"]+)/i);\n                linkEmbed       = linkEmbed != null ? linkEmbed[1] : false;\n\n                linkEmbed !== false && hosts.push({\n                    provider: {\n                        url: detailUrl,\n                        name: \"seehduno\"\n                    },\n                    result: {\n                        file: linkEmbed,\n                        label: \"embed\",\n                        type: \"embed\"\n                    }\n                });\n            }\n        });\n\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const seehduno = new SeehdUno({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await seehduno.searchDetail();\n    await seehduno.getHostFromDetail();\n    return seehduno.state.hosts;\n}\n\n\nexports.testing = SeehdUno;",
  "host_teamdk": "class Teamdk {\n\n    constructor(props) {\n\n        this.libs = props.libs;\n        this.settings = props.settings;\n        this.state = {};\n\n\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url, {\n            \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\"\n        });\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n        let sources = [];\n        var arrLink = [];\n\n        let htmlDetail  = await this.checkLive(url);\n\n        if( htmlDetail == false )throw new Error(\"LINK DIE\");\n\n        let linkPlay    = htmlDetail.match(/sources: \\[([^\\]]+)/i);\n        linkPlay        = linkPlay != null ? linkPlay[1] : false;\n\n        if( linkPlay != false ) {\n\n            linkPlay = `arrLink = [${linkPlay}]`;\n            eval(linkPlay);\n        \n            if( arrLink.length > 0 ) {\n        \n                let arrPromise = arrLink.map(async function(value) {\n                    \n                    let isDie = await httpRequest.isLinkDie(value.file);\n\n                    if( isDie != false ) {\n\n                        sources.push({\n                            label: value.label,\n                            file: value.file,\n                            type: \"embed\",\n                            size: isDie\n                        });\n                    }\n                    \n                });\n\n                await Promise.all(arrPromise);\n                \n                return {\n                    host: {\n                        url: url,\n                        name: \"teamdk\"\n                    },\n                    result: sources\n                }\n            }\n           \n          }\n\n\n        \n    }\n}\n\nexports.default = (libs, settings) => new Teamdk({ libs, settings });",
  "provider_gowatchfreemovies": "const URL = {\n    DOMAIN: \"http://www.gowatchfreemovies.to\",\n    SEARCH: (title) => {\n        return `http://www.gowatchfreemovies.to/?keyword=${title}&search_section=2`;\n    }\n};\n\nclass FreeMovies {\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n\n        this.state = {};\n    }\n\n\n\n    async searchDetail() {\n        const { httpRequest, cheerio, stringHelper } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let detailUrl   = false;\n        let htmlSearch  = await httpRequest.get(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')), {});\n        let $           = cheerio.load(htmlSearch.data);\n        let item        = $('.item');\n\n        item.each(function() {\n            \n            let hrefFree    = URL.DOMAIN + $(this).find('a').attr('href');\n\t\t\tlet titleTemp   = $(this).find('a').attr('title');\n\t\t\ttitleTemp       = titleTemp.replace('Watch Putlocker', '').trim();\n\t\t\tlet yearFree    = titleTemp.match(/\\(([^\\)]+)/i);\n\t\t\tyearFree        = yearFree != null ? yearFree[1] : 0;\n            let titleFree   = titleTemp.replace(/\\(.*/i, '');\n            \n            if( stringHelper.shallowCompare(title, titleFree) && +yearFree == year ) {\n\n\t\t\t\tif( hrefFree.indexOf('-tv-show-') != -1 && type == 'tv' ) {\n\n                    hrefFree    = `${hrefFree}/season-${season}-episode-${episode}`;\n\t                hrefFree    = hrefFree.replace('watch-', 'tv-');\n                    detailUrl   = hrefFree;\n\t\t\t\t} else if(hrefFree.indexOf('-movie-') != -1 && type == 'movie') {\n\n                    detailUrl   = hrefFree;\n\t\t\t\t}\n\t\t\t}\n        });\n\n\n        this.state.detailUrl = detailUrl;\n        return;\n    }\n\n    async getHostFromDetail() {\n        const { httpRequest, cheerio } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let detailUrl       = this.state.detailUrl;\n        let hosts           = [];\n        let arrRedirects    = [];\n        let htmlDetail      = await httpRequest.get(this.state.detailUrl, {});\n        let $               = cheerio.load(htmlDetail.data);\n        let item            = $('.link_item');\n\n        item.each(function() {\n\n            let linkRedirect    = URL.DOMAIN + $(this).find('tbody tr .link_middle strong a').attr('href');\n\n            arrRedirects.push(linkRedirect);\n        });\n\n        let arrPromise = arrRedirects.map(async function(val) {\n\n            let linkEmbed = await httpRequest.getRedirectUrl(val);\n            linkEmbed && hosts.push({\n                provider: {\n                    url: detailUrl,\n                    name: \"gowatchfreemovies\"\n                },\n                result: {\n                    file: linkEmbed,\n                    label: \"embed\",\n                    type: \"embed\"\n                }\n            });\n\n        });\n\n        await Promise.all(arrPromise);\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const freemovies = new FreeMovies({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await freemovies.searchDetail();\n    await freemovies.getHostFromDetail();\n    return freemovies.state.hosts;\n}\n\n\nexports.testing = FreeMovies;",
  "provider_m4ufree": "const URL = {\n    DOMAIN: \"http://m4ufree.club\",\n    SEARCH: (title) => {\n        return `http://m4ufree.club/search-movies/${title}.html`;\n    },\n    HEADERS: {\n        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'\n    }\n};\n\nclass M4uFree {\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n\n        this.state      = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let detailUrl   = false;\n        let htmlSearch  = await httpRequest.get(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')));\n        let currentPage = false;\n        let $           = cheerio.load(htmlSearch);\n        let page        = $('.pages a');\n        if( page ) {\n            page        = 1;\n            currentPage = URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')) \n        } else {\n            currentPage = page.last().attr('href');\n            page        = currentPage.match(/page\\-([0-9]+)/i);\n            page        = page != null ? +page[1] : 1;\n        }\n\n        this.state.detailUrl = await this.getDetailUrl(page, currentPage, this.state, this.state.detailUrl);\n        return;\n    }\n\n\n    async getDetailUrl(page, currentPage) {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        for( let val = 1; val <= page; val++ ) {\n\n            let hrefPage        = currentPage.replace(/page\\-[0-9]+/i, `page-${val}`);\n            let htmlCurrentPage = await httpRequest.get(hrefPage, URL.HEADERS);\n            let $_2             = cheerio.load(htmlCurrentPage.data);\n            let item            = $_2('.item');\n            let arrItem         = [];\n\n            item.each(function() {\n    \n                let hrefM4u \t= $_2(this).find('.item p b a').attr('href');\n                let titleM4u \t= $_2(this).find('.item p b a').text();\n                let checkMovies = titleM4u.match(/ *season *[0-9]+/i);\n                let seasonNumber= checkMovies != null ? titleM4u.match(/season *([0-9]+)/i) != null ? titleM4u.match(/season *([0-9]+)/i)[1] : 0 : false;\n                let infoM4u\t\t= $_2(this).find('.item p b a').attr('onmouseover');\n                let yearM4u \t= infoM4u.match(/release *\\: *([0-9]+)/i);\n                yearM4u\t\t\t= yearM4u != null ? +yearM4u[1] : 0;\n                titleM4u\t\t= titleM4u.replace(/ *\\: *season.*/i, '');\n                \n                arrItem.push({\n                    hrefM4u: hrefM4u,\n                    titleM4u: titleM4u,\n                    seasonNumber: seasonNumber,\n                    yearM4u: yearM4u, \n                    checkMovies: checkMovies\n                });\n            });\n\n            for( let item in arrItem ) {\n\n                if( stringHelper.shallowCompare(arrItem[item].titleM4u, title) )  {\n    \n                    if( arrItem[item].checkMovies == null && type == 'movie' && year == arrItem[item].yearM4u ) {\n                        \n                        return arrItem[item].hrefM4u;\n                    } else if( arrItem[item].checkMovies != null && type == 'tv' ) {\n    \n                        if( +arrItem[item].seasonNumber == season ) {\n                            \n                            let $_3         = await httpRequest.get(arrItem[item].hrefM4u, URL.HEADERS);\n                            let itemEpisode = $_3('#details .episode');\n    \n                            itemEpisode.each(function() {\n    \n                                let hrefEpisode \t= $(this).attr('href');\n                                let numberEpisode\t= $(this).text();    \n                                \n                                if( numberEpisode == episode ) {\n                                    return hrefEpisode;\n                                }\n                            });\n                            return false;\n                        }\n                    } \n                }\n            }\n        }\n    }\n\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let hosts       = [];\n        let arrDetail   = [];\n        let detailUrl   = this.state.detailUrl;\n        let htmlDetail  = await httpRequest.get(this.state.detailUrl);\n        let $           = cheerio.load(htmlDetail.data);\n        let item        = $('#total_version .server_line');\n\n        item.each(function() {\n\n            let links = $(this).find('.server_version a').attr('href');\n            arrDetail.push(links);\n        });\n\n\n        let arrPromise = arrDetail.map(async function(links) {\n\n            let htmlData    = await httpRequest.get(links);\n            let encode \t    = htmlData.data.match(/Base64\\.decode\\(\\\"([^\\\"]+)/i);\n            encode \t\t    = encode != null ? encode[1] : false;\n\n            if( encode ) {\n                let iframes \t= base64.decode(encode);\n                let linkEmbed \t= iframes.match(/src\\=\\\"([^\\\"]+)/i); \n                linkEmbed\t\t= linkEmbed != null ? linkEmbed[1] : false;\n                \n                linkEmbed && hosts.push({\n                    provider: {\n                        url: detailUrl,\n                        name: \"m4ufree\"\n                    },\n                    result: {\n                        file: linkEmbed,\n                        label: \"embed\",\n                        type: \"embed\"\n                    }\n                });\n            }\n        });\n\n        await Promise.all(arrPromise);\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const m4ufree = new M4uFree({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await m4ufree.searchDetail();\n    await m4ufree.getHostFromDetail();\n    return m4ufree.state.hosts;\n}\n\n\nexports.testing = M4uFree;",
  "provider_seehd": "const URL = {\n   DOMAIN: 'http://www.seehd.pl',\n   SEARCH: (title, page=false) => {\n\n        if( page != false ) {\n            return `http://www.seehd.pl/page/${page}/?s=${title}`;\n        }\n       return `http://www.seehd.pl/?s=${title}`;\n   }\n};\n\nclass Seehd {\n\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n        this.state      = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let htmlSearch  = await httpRequest.getCloudflare(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')));\n        htmlSearch      = htmlSearch.data;\n        let $           = cheerio.load(htmlSearch);\n        let page        = $('.pagination-item').text();\n        if( !page ) {\n            page = 1;\n        } else {\n            page = page.match(/page *[0-9]* *of *([0-9]*)/i);\n            page = page != null ? +page[1] : 1;\n        }\n\n        await this.getDetailUrl(page, this.state);\n\n        return;\n    }\n\n    async getDetailUrl(page, state) {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        for( let i = 1; i <= page; i++ ) {\n\n            let htmlSearch  = await httpRequest.getCloudflare(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+'), i));\n            let $           = cheerio.load(htmlSearch.data);\n            let itemPage    = $('.type-post');\n\n            itemPage.each(function() {\n\n                let hrefMovie   = $(this).find('div > div').attr('data-url');\n                let titleMovie  = $(this).find('div > div > header.entry-header > h2 > a').text();\n                titleMovie      = titleMovie.replace('Watch Online', '').trim();\n                let yearMovie   = titleMovie.split(' ');\n                yearMovie       = yearMovie.length > 0 ? yearMovie[yearMovie.length - 1] : 0;\n                titleMovie      = titleMovie.replace(yearMovie, '').trim();    \n\n\n                if( stringHelper.shallowCompare(title, titleMovie) ) {\n\n\n                    if( type == 'movie' && year == +yearMovie ) {\n\n                        state.detailUrl = hrefMovie;\n                    } else if( type == 'tv' ) {\n\n                        let seasonMovie = yearMovie.match(/S([0-9]+)/i);\n                        seasonMovie = seasonMovie != null ? +seasonMovie[1]  : 0;\n                        let episodeMovie = yearMovie.match(/E([0-9]+)/i);\n                        episodeMovie = episodeMovie  != null ? +episodeMovie[1] : 0;\n\n                        if( season == seasonMovie && episode == episodeMovie ) {\n                            state.detailUrl = hrefMovie;\n                            \n                        }\n                    }\n                } \n            });\n\n            return;\n        }\n    }\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let hosts       = [];\n        let detailUrl   = this.state.detailUrl;\n\n        let htmlDetail  = await httpRequest.getCloudflare(this.state.detailUrl);\n        htmlDetail      = htmlDetail.data;\n        let $           = cheerio.load(htmlDetail);\n        let itemEmbed   = $('.tabcontent');\n\n        itemEmbed.each(function() {\n            \n            let linkEmbed = $(this).find('center > iframe').attr('src');\n\n            linkEmbed !== false && hosts.push({\n                provider: {\n                    url: detailUrl,\n                    name: \"seehd\"\n                },\n                result: {\n                    file: linkEmbed,\n                    label: \"embed\",\n                    type: \"embed\"\n                }\n            });\n        });\n\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const seehd = new Seehd({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await seehd.searchDetail();\n    await seehd.getHostFromDetail();\n    return seehd.state.hosts;\n}\n\n\nexports.testing = Seehd;",
  "provider_putlockerhd": "const URL = {\n    DOMAIN: `https://putlockerhd.co`,\n    SEARCH: (title) => {\n        return `https://putlockerhd.co/results?q=${title}`;\n    }\n};\n\nclass PutlockerHd {\n    constructor(props) {\n        this.libs       = props.libs;\n        this.movieInfo  = props.movieInfo;\n        this.settings   = props.settings;\n\n        this.state = {};\n    }\n\n    async searchDetail() {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        let detailUrl   = false;\n        let htmlSearch  = await httpRequest.get(URL.SEARCH(stringHelper.convertToSearchQueryString(title), '+'));\n        let $           = cheerio.load(htmlSearch);\n        let page        = $('.pagination li').last().find('a').text();\n\n        if( page.indexOf('current') != 1 ) {\n            page = 1;\n        }\n\n        await this.getDetailUrl(page, this.state);\n\n        return;\n    }\n\n\n    async getDetailUrl(page, state) {\n\n        const { httpRequest, cheerio, stringHelper, base64 } = this.libs; \n        let { title, year, season, episode, type } = this.movieInfo;\n\n        for( let i = 1; i <= page; i++ )  {\n\n            let currentPage = i != 1 ? `&page=${i}`  : '';\n            let htmlSearch  = await httpRequest.getHTML(URL.SEARCH(stringHelper.convertToSearchQueryString(title, '+')) + currentPage);\n            let $           = cheerio.load(htmlSearch); \n            let itemPage    = $('.video_container');\n\n\n            itemPage.each(function() {\n\n                let titleMovies = $(this).find('.video_title h3 a').html();\n                let hrefMovies \t= URL.DOMAIN + $(this).find('.video_title h3 a').attr('href');\n                let yearMovies \t= $(this).find('.video_title h3 a').attr('title');\n                yearMovies \t\t= yearMovies.match(/\\(([0-9]+)/i);\n                yearMovies \t\t= yearMovies != null ? +yearMovies[1] : 0;\n                \n                if( stringHelper.shallowCompare(title, titleMovies) && yearMovies == year ) { \n                    state.detailUrl = hrefMovies;\n                }\n            });\n\n            return;\n        }\n    }\n\n\n    async getHostFromDetail() {\n\n        const { httpRequest, cheerio, base64 } = this.libs;\n        if(!this.state.detailUrl) throw new Error(\"NOT_FOUND\");\n\n        let hosts       = [];\n        let htmlDetail  = await httpRequest.getHTML(this.state.detailUrl);\n        let $           = cheerio.load(htmlDetail);\n        let linkEmbed   = htmlDetail.match(/var *frame_url *\\= *\\\"([^\\\"]+)/i);\n        linkEmbed       = linkEmbed != false ? `http:${linkEmbed[1]}` : false;\n\n\n        linkEmbed !== false && hosts.push({\n            provider: {\n                url: this.state.detailUrl,\n                name: \"putlockerhd\"\n            },\n            result: {\n                file: linkEmbed,\n                label: \"embed\",\n                type: \"embed\"\n            }\n        });\n\n        this.state.hosts = hosts;\n    }\n\n}\n\nexports.default = async (libs, movieInfo, settings) => {\n\n    const putlocker = new PutlockerHd({\n        libs: libs,\n        movieInfo: movieInfo,\n        settings: settings\n    });\n    await putlocker.searchDetail();\n    await putlocker.getHostFromDetail();\n    return putlocker.state.hosts;\n}\n\n\nexports.testing = PutlockerHd;",
  "listprovider": "{\"primeware\":{\"name\":\"primeware\",\"domain\":\"primeware.ag\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/primeware.js\",\"type\":[\"movie\",\"tv\"]},\"afdah\":{\"name\":\"afdah\",\"domain\":\"afdah.to\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/afdah.js\",\"type\":[\"movie\"]},\"alluc-hand\":{\"name\":\"alluc-hand\",\"domain\":\"alluc.ee\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/alluc-hand.js\",\"type\":[\"movie\",\"tv\"]},\"flixanity\":{\"name\":\"flixanity\",\"domain\":\"flixanity.mobi\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/flixanity.js\",\"type\":[\"movie\",\"tv\"]},\"gowatchfreemovies\":{\"name\":\"gowatchfreemovies\",\"domain\":\"gowatchfreemovies.to\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/gowatchfreemovies.js\",\"type\":[\"movie\",\"tv\"]},\"m4ufree\":{\"name\":\"m4ufree\",\"domain\":\"m4ufree.club\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/m4ufree.js\",\"type\":[\"movie\",\"tv\"]},\"mytv\":{\"name\":\"mytv\",\"domain\":\"api.teatv.net\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/mytv.js\",\"type\":[\"movie\",\"tv\"]},\"playdk\":{\"name\":\"playdk\",\"domain\":\"api.teatv.net\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/playdk.js\",\"type\":[\"movie\",\"tv\"]},\"putlockerhd\":{\"name\":\"putlockerhd\",\"domain\":\"api.teatv.net\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/putlockerhd.js\",\"type\":[\"movie\",\"tv\"]},\"seehd\":{\"name\":\"seehd\",\"domain\":\"api.teatv.net\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/seehd.js\",\"type\":[\"movie\",\"tv\"]},\"seehduno\":{\"name\":\"seehduno\",\"domain\":\"api.teatv.net\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/providers/seehduno.js\",\"type\":[\"tv\",\"movie\"]}}",
  "host_openload": "class Openload {\n\n    constructor(props) {\n\n        this.libs = props.libs;\n        this.settings = props.settings;\n        this.state = {};\n    }\n\n    async getOpenload(url) {\n\n        const { httpRequest, jsdom } = this.libs;\n        const { JSDOM } = jsdom;\n        const jqueryUrl = \"http://code.jquery.com/jquery-1.11.0.min.js\";\n        let html = await httpRequest.getHTML(url);\n        if (html.indexOf('<h3>Weâ€™re Sorry!</h3>') > -1) throw new Error(\"Invalid fileId\");\n        let jquery = await httpRequest.getHTML(jqueryUrl);\n        const dom = new JSDOM(html, {\n            runScripts: \"outside-only\"\n        });\n        const window = dom.window;\n        window.eval(jquery);\n        var script = html.substring(html.indexOf(\"ï¾ŸÏ‰ï¾Ÿï¾‰= /ï½€ï½Â´\"));\n        script = script.substring(0, script.indexOf(\"</script>\"));\n        window.eval(script);\n        script = script.substring(script.indexOf(\"$(document)\"));\n        script = script.substring(script.indexOf(\"var\"))\n        script = script.substring(0, script.indexOf(\"ï¾ŸÏ‰ï¾Ÿ\"))\n        script = script.substring(0, script.lastIndexOf(\"});\"))\n        script = script.replace(\"document.createTextNode.toString().indexOf('[native code')\", \"1\");\n        script = script.replace(\"_0x3d7b02=[];\", \"\");\n        window.eval(script);\n        let streamUrl = window.document.getElementById(\"streamurj\").innerHTML;\n        let opl = \"https://openload.co/stream/\" + streamUrl + \"?mime=true\";\n        let isDie = await httpRequest.isLinkDie(opl);\n\n        if( isDie == false ) throw new Error(\"NOT LINK\");\n        return {\n            host: {\n                url: url,\n                name: \"openload\"\n            },\n            result: [{ file: opl, label: \"NOR\", type: \"embed\", size: isDie }]\n        }\n    }\n    \n    async checkLive(url)  {\n    \n        let { httpRequest } = this.libs;\n    \n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url);\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n    \n    async getUsingAPI (url) {\n    \n        const { httpRequest, cryptoJs } = this.libs;\n        const html = await this.checkLive(url);\n    \n        if( html == false ) throw new Error(\"LINK DIE\");\n    \n        const token = cryptoJs.MD5(html + \"teatv-openload\").toString();\n        const apiResponse = await httpRequest.post(\"https://api.teatv.net/api/v2/get_opl\", {\n            \"Content-Type\": \"application/json\"\n        }, JSON.stringify({\n            data: html,\n            token: token\n        }));\n    \n        let isDie = await httpRequest.isLinkDie(apiResponse.data.data);\n        if( isDie == false ) throw new Error(\"LINK DIE\");\n        \n        const { status, data, error } = apiResponse.data;\n        if(error) throw new Error(error);\n        if(status == 200) return {\n            host: {\n                url: url,\n                name: \"openload\",\n                type: \"embed\"\n                \n            },\n            result: [{ file: data, label: \"NOR\", type: \"embed\", size: isDie }]\n        }\n    }\n    convertToEmbed() {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let data;\n        try {\n            data = await this.getOpenload(url);\n        } catch(err) {\n            console.log(err);\n            data = await this.getUsingAPI(url);\n        }\n        \n        return data;\n    }\n}\n\nexports.default = (libs, settings) => new Openload({ libs, settings })",
  "listhost": "{\"streamango\":{\"name\":\"streamango\",\"domain\":\"streamango.com\",\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/streamango.js\"},\"openload\":{\"name\":\"openload\",\"domain\":[\"openload.com\",\"openload.co\",\"oload.tv\",\"oload.stream\",\"oload.info\"],\"version\":\"0.0.5\",\"url\":\"http://localhost:8000/hosts/openload.js\"},\"teamdk\":{\"name\":\"teamdk\",\"domain\":[\"teamdk.net\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/teamdk.js\"},\"estream\":{\"name\":\"estream\",\"domain\":[\"estream.to\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/estream.js\"},\"thevideo\":{\"name\":\"thevideo\",\"domain\":[\"thevideo.me\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/thevideo.js\"},\"vidlink\":{\"name\":\"vidlink\",\"domain\":[\"vidlink.org\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/vidlink.js\"},\"vidoza\":{\"name\":\"vidoza\",\"domain\":[\"vidoza.net\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/vidoza.js\"},\"vidstreaming\":{\"name\":\"vidstreaming\",\"domain\":[\"vidstreaming.net\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/vidstreaming.js\"},\"vidushare\":{\"name\":\"vidushare\",\"domain\":[\"vidushare.com\"],\"version\":\"0.0.1\",\"url\":\"http://localhost:8000/hosts/vidushare.js\"}}",
  "host_estream": "class Estream {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url);\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed() {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let html    = await this.checkLive(url);\n\n        if( html == false ) throw new Error(\"LINK DIE\");\n\n        let $       = cheerio.load(html);\n        let sources = [];\n        let temp    = [];\n\n        $(\"video source\").each(function() {\n            var label =\n            $(this).attr(\"type\") !== \"video/mp4\"\n                ? \"NOR\"\n                : $(this).attr(\"res\") === \"854x480\" ? \"480p\" : \"360p\";\n\n            temp.push({\n                label: label,\n                file: $(this).attr(\"src\"),\n                type: \"embed\"\n            });\n        });\n\n\n        let arrPromise = temp.map(async function(val) {\n\n            let isDie = await httpRequest.isLinkDie(val.file);\n\n            if( isDie != false )  {\n                val.size = isDie;\n                sources.push(val);\n            }\n        });\n\n        await Promise.all(arrPromise);        \n\n        return {\n            host: {\n                url: url,\n                name: \"estream\"\n            },\n            result: sources\n        }\n    }\n}\n\nexports.default = (libs, settings) => new Estream({ libs, settings });",
  "host_thevideo": "class TheVideo {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n\n\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url, {\n            \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\"\n        });\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n        let sources = [];\n\n        let htmlDetail = await this.checkLive(url);\n\n        if( htmlDetail == false ) throw new Error(\"LINK DIE\");\n\n        let linkPlay = htmlDetail.match(/sources *: *\\[([^\\]]+)/i);\n        linkPlay = linkPlay != null ? linkPlay[1] : '';\n\n\n        linkPlay = eval(`[${linkPlay}]`);\n        let arrPromise = linkPlay.map(async function(value) {\n            \n            let isDie = await httpRequest.isLinkDie(value.file);\n\n            if( isDie != false ) {\n\n                sources.push({\n                    file: value.file, label: value.label, type: \"embed\" , size: isDie\n                });\n            }\n            \n        });\n\n        await Promise.all(arrPromise);\n\n\n        return {\n            host: {\n                url: url,\n                name: \"thevideo\"\n            },\n            result: sources\n        }\n    }\n}\n\nexports.default = (libs, settings) => new TheVideo({ libs, settings });",
  "host_vidlink": "class VidLink {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n\n    }\n\n    async checkLive(id) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.post(`http://vidlink.org/streamdrive/info/${id}`, {\n            \"Content-Type\": \"application/x-www-form-urlencoded\" \n        }, {\n            browserName: \"Chrome\",\n            platform: \"MacIntel\" \n        });\n        html = html.data;\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getRedirect(url) {\n\n        const { httpRequest } = this.libs;\n\n        return [{\n            file: url,\n            label: \"HD\",\n            type: \"embed\",\n            size: \"\"\n        }];\n\n    } \n\n    async getEmbed(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let sources = [];\n        let temp    = [];\n\n        let urlParts = url.split(\"/\");\n        let id = urlParts[urlParts.length - 1 ];\n        try {\n\n            let postResponse = await this.checkLive(id);\n\n            if( postResponse == false )  throw new Error(\"LINK DIE\");\n\n            let { data } = postResponse;\n\n            let resultArr = data.map((val, index) => {\n                if(val.status == 403) throw new Error(\"NOT LINK\");\n\n                temp.push({\n                    file: val.url,\n                    label: \"HD\",\n                    type: \"embed\" \n                });\n\n            }).filter(val => val !== undefined);\n\n            let arrPromise = temp.map(async function(val) {\n\n                let isDie = await httpRequest.isLinkDie(val.file);\n    \n                if( isDie != false )  {\n                    val.size = isDie;\n                    sources.push(val);\n                }\n            });\n    \n            await Promise.all(arrPromise); \n\n            return sources;\n            \n\n        } catch(err) {\n            throw new Error(err)\n        }\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let sources = [];\n\n        if( url.includes('redirect') ) {\n           \n            sources = await this.getRedirect(url);\n            return {\n                host: {\n                    url: url,\n                    name: \"vidlink\"\n                },\n                result: sources\n            } \n        } else {\n\n            sources = await this.getEmbed(url);\n            return {\n                host: {\n                    url: url,\n                    name: \"vidlink\"\n                },\n                result: sources\n            }\n        }\n\n\n    }\n}\n\nexports.default = (libs, settings) => new VidLink({ libs, settings });",
  "host_vidoza": "class Vidoza {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url);\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let sources     = [];\n        let html        = await this.checkLive(url);\n\n        if( html == false )  throw new Error(\"LINK DIE\");\n\n        let startIndex  = html.indexOf('jwplayer(\"vplayer\").setup');\n        html            = html.substring(startIndex);\n        html            = html.substring(0, html.indexOf(\".setVolume(\"));\n        html            = html.replace('jwplayer(\"vplayer\").setup', \"player = \");\n        html            += \";\";\n\n        var player;\n        eval(html);\n        let data = player.sources;\n\n        let arrPromise = data.map( async val => {\n            \n            let isDie = await httpRequest.isLinkDie(val.file);\n\n            if( isDie != false ) {\n\n                sources.push({\n                    label: val.file.indexOf(\"mp4\") !== -1 ? val.label : \"NOR\",\n                    file: val.file,\n                    type: \"embed\",\n                    size: isDie\n                });\n            }\n        \n\n        });\n\n        await Promise.all(arrPromise);\n\n        return {\n            host: {\n                url: url,\n                name: \"vidoza\"\n            },\n            result: sources\n        }\n\n    }\n}\n\nexports.default = (libs, settings) => new Vidoza({ libs, settings });",
  "host_vidstreaming": "class Vidstreaming {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getHTML(url);\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        if(url.indexOf(\"//\") === 0) {\n            url = \"http:\" + url;\n        }\n        let sources = [];\n        let html    = await this.checkLive(link);\n\n        if( html == false ) throw new Error(\"LINK DIE\");\n\n        let $       = cheeri.load(html);\n        let file    = $(\"video\").attr(\"src\");\n\n        let isDie   = await httpRequest.isLinkDie(file);\n\n        if( isDie != false ) {\n            sources =[{ file, label: \"NOR\", type: 'embed', size: isDie }]; \n        }  else {\n            sources = [];\n        }\n\n        return {\n            host: {\n                url: url,\n                name: \"vidstreaming\"\n            },\n            result: sources\n        }\n\n    }\n}\n\nexports.default = (libs, settings) => new Vidstreaming({ libs, settings });",
  "host_vidushare": "class ViduShare {\n\n    constructor(props) {\n\n        this.libs       = props.libs;\n        this.settings   = props.settings;\n        this.state      = {};\n\n    }\n\n    async checkLive(url) {\n\n        let { httpRequest } = this.libs;\n\n        // you fill the die status text\n        // const dieStatusText = \"\";\n        let html = await httpRequest.getRedirectUrl(url);\n        // if(html.includes(dieStatusText)) return true;\n        return html;\n    }\n\n    convertToEmbed(url) {\n        \n        // convert link detail to link embed\n        // if input is embed then return input\n\n        // let id = url.match(/\\/embed\\-([^\\-]+)/i);\n        // id = url != null ? url[1] : false;\n\n        // if( id == false ) return url;\n\n    }\n\n    async getLink(url) {\n\n        const { httpRequest, cheerio } = this.libs;\n\n        let arr     = [];\n        let result  = await this.checkLive(url); \n\n        if( result == false ) throw new Error(\"LINK DIE\");\n\n        let isDie = await httpRequest.isLinkDie(result);\n\n        if( isDie != false ) {\n            arr = [\n                { file: result,\n                label: 'HD', type: 'direct', size: isDie }\n            ];\n        } else {\n            arr = [];\n        }\n\n        return {\n            host: {\n                url: url,\n                name: \"vidushare\"\n            },\n            result: sources\n        }\n\n    }\n}\n\nexports.default = (libs, settings) => new ViduShare({ libs, settings });"
}